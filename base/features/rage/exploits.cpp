#include "exploits.h"
#include "../../core/hooks.h"

bool CExploits::ShouldRecharge( ) {
    if ( !ctx.m_bExploitsEnabled )
        return false;

    if ( Config::Get<bool>( Vars.MiscFakeDuck ) && Config::Get<keybind_t>( Vars.MiscFakeDuckKey ).enabled )
        return false;

    if ( ( Interfaces::Globals->flCurTime - ctx.m_pLocal->m_flSpawnTime( ) ) < 1.f )
        return false;

    if ( ctx.m_iTicksAllowed >= 14 )
        return false;

    const auto extraTicks{ std::max( **( int** )Offsets::Sigs.numticks - 1, 0 ) };

    if ( extraTicks + ctx.m_iTicksAllowed >= 16 )
        return false;

    if ( m_iRechargeCmd != Interfaces::ClientState->iLastOutgoingCommand
        && Interfaces::ClientState->nChokedCommands )
        return false;

    if ( abs( Interfaces::Globals->flRealTime - ctx.m_iLastShotTime ) < 0.5f )
        return false;

    if ( Features::Ragebot.m_bShouldStop )
        return false;

    m_iRechargeCmd = Interfaces::ClientState->iLastOutgoingCommand;

    ++ctx.m_iTicksAllowed;

    return true;
}

int CExploits::AdjustTickbase( const int old_new_cmds, const int total_new_cmds, const int delta ) {
    auto ret = -1;

    const auto correction_ticks = ctx.CalcCorrectionTicks( );
    if ( correction_ticks != -1 ) {
        const auto& prev_local_data = ctx.m_cLocalData.at( Interfaces::ClientState->iLastOutgoingCommand % 150 );
        if ( prev_local_data.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( ) ) {
            ret = prev_local_data.PredictedNetvars.m_nTickBase + 1;

            const auto tick_count = ret + old_new_cmds - m_iCorrectionAmount;

            const auto ideal_final_tick = tick_count + correction_ticks;

            const auto too_fast_limit = ideal_final_tick + correction_ticks;
            const auto too_slow_limit = ideal_final_tick - correction_ticks;

            const auto adjusted_final_tick = ret + total_new_cmds;

            if ( adjusted_final_tick > too_fast_limit
                || adjusted_final_tick < too_slow_limit ) {
                ret = ideal_final_tick - total_new_cmds;
            }
        }
    }

    if ( ret != -1 )
        return ret;

    const auto& local_data = ctx.m_cLocalData.at( ( Interfaces::ClientState->iLastOutgoingCommand + 1 ) % 150 );

    return ( local_data.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( )
        ? local_data.PredictedNetvars.m_nTickBase : ctx.m_pLocal->m_nTickBase( ) ) - delta;
}

void WriteUserCmd( void* buf, CUserCmd* incmd, CUserCmd* outcmd ) {
    using WriteUsercmd_t = void( __fastcall* )( void*, CUserCmd*, CUserCmd* );
    static WriteUsercmd_t WriteUsercmdF = reinterpret_cast< WriteUsercmd_t >( Offsets::Sigs.WriteUsercmd );

    __asm
    {
        mov     ecx, buf
        mov     edx, incmd
        push    outcmd
        call    WriteUsercmdF
        add     esp, 4
    }
}


bool CExploits::Shift( void* ecx, void* edx, int slot, bf_write* buf, int from, int to, MoveMsg_t* move_msg ) {
    const auto newCmds = std::min( move_msg->m_iNewCmds + ctx.m_iTicksAllowed, 16 );

    auto maxShiftedCmds = newCmds - move_msg->m_iNewCmds;
    auto shiftAmount{ maxShiftedCmds };

    if ( m_bRealCmds )
        maxShiftedCmds -= m_iShiftAmount;

    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    const auto old_new_cmds = move_msg->m_iNewCmds;

    move_msg->m_iNewCmds = std::clamp( move_msg->m_iNewCmds + shiftAmount, 1, 62 );
    move_msg->m_iBackupCmds = 0;

    auto first_tick_base = AdjustTickbase( old_new_cmds, move_msg->m_iNewCmds, shiftAmount );

    const auto nextCmdNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

    static auto oWriteUserCmdDeltaToBuffer = DTR::WriteUserCmdDeltaToBuffer.GetOriginal<decltype( &Hooks::hkWriteUserCmdDeltaToBuffer )>( );
    bool stoplol{ };
    for ( to = nextCmdNumber - old_new_cmds + 1; to <= nextCmdNumber; ++to ) {
        if ( !oWriteUserCmdDeltaToBuffer( ecx, edx, slot, buf, from, to, true ) ) {
            stoplol = true;
            break;
        }

        from = to;
    }

    if ( stoplol )
        return true;

    for ( auto i = Interfaces::ClientState->iLastOutgoingCommand + 1; i <= nextCmdNumber; ++i ) {
        auto& local_data = ctx.m_cLocalData.at( i % 150 );

        local_data.m_iShiftAmount = m_bRealCmds ? 0 : shiftAmount;
        local_data.m_iAdjustedTickbase = first_tick_base++;
        local_data.m_bOverrideTickbase = true;
        local_data.m_bRestoreTickbase = !m_bRealCmds;
    }

    const auto userCmd = Interfaces::Input->GetUserCmd( from );
    if ( !userCmd )
        return false;

    auto from_user_cmd = *userCmd, toUserCmd = *userCmd;

    if ( m_bRealCmds ) {
        while ( shiftAmount > 0 ) {
            ++Interfaces::ClientState->nChokedCommands;
            ++Interfaces::ClientState->pNetChannel->iChokedPackets;
            ++Interfaces::ClientState->pNetChannel->iOutSequenceNr;

            ++toUserCmd.iCommandNumber;

            Interfaces::Prediction->Update( Interfaces::ClientState->iDeltaTick,
                Interfaces::ClientState->iDeltaTick > 0,
                Interfaces::ClientState->iLastCommandAck,
                Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands );


            toUserCmd.iButtons &= ~( IN_ATTACK | IN_ATTACK2 | IN_USE | IN_BULLRUSH | IN_SPEED | IN_WALK | IN_ZOOM | IN_JUMP );
            //if ( ctx.m_bFakeDucking )
            //   toUserCmd.iButtons |= IN_DUCK;
            //toUserCmd.iButtons &= 0x410006u;
            toUserCmd.bHasBeenPredicted = toUserCmd.iTickCount == 0x7F7FFFFF;

            toUserCmd.flForwardMove = Features::Misc.m_ve2OldMovement.x;
            toUserCmd.flSideMove = Features::Misc.m_ve2OldMovement.y;

            if ( Config::Get<bool>( Vars.MiscBunnyhop ) && Features::Misc.m_bWasJumping ) {
                if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND )
                    toUserCmd.iButtons |= IN_JUMP;
            }

            --shiftAmount;

            if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND
                && ( toUserCmd.flForwardMove || toUserCmd.flSideMove ) 
                && !shiftAmount
                && Config::Get<bool>( Vars.ExploitsDoubletap ) && Config::Get<keybind_t>( Vars.ExploitsDoubletapKey ).enabled ) {
                Features::Ragebot.m_bShouldStop = true;
                Features::Misc.AutoStop( toUserCmd );
            }

            Features::Misc.AutoPeek( toUserCmd );
            Features::Misc.MoveMINTFix( toUserCmd, ctx.m_angOriginalViewangles, ctx.m_pLocal->m_fFlags( ), ctx.m_pLocal->m_MoveType( ) );
            Features::Misc.NormalizeMovement( toUserCmd );

            Features::AnimSys.UpdateLocal( toUserCmd.viewAngles, false );

            auto& LocalData = ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 );
            LocalData.m_bOverrideTickbase = true;
            LocalData.m_iAdjustedTickbase = first_tick_base++;
            LocalData.m_iCommandNumber = toUserCmd.iCommandNumber;

            Interfaces::Input->pCommands[ toUserCmd.iCommandNumber % 150 ] = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );

            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

            from_user_cmd = toUserCmd;
        }

        ctx.m_iSentCmds.push_back( Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 );
    }
    else {
        toUserCmd.iTickCount = INT_MAX;

        do {
            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

            from_user_cmd = toUserCmd;

            ++toUserCmd.iCommandNumber;

            auto& LocalData = ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 );
            LocalData.m_bOverrideTickbase = true;
            LocalData.m_iAdjustedTickbase = first_tick_base++;
            LocalData.m_iCommandNumber = toUserCmd.iCommandNumber;

            --shiftAmount;
        } while ( shiftAmount );
    }

    // only on realcmds?
    Interfaces::Prediction->iPreviousStartFrame = -1;
    Interfaces::Prediction->Split->nCommandsPredicted = 0;

    return false;
}

bool CExploits::BreakLC( void* ecx, void* edx, int slot, bf_write* buf, int from, int to, MoveMsg_t* move_msg, bool finalRun ) {
    const auto newCmds = std::min( move_msg->m_iNewCmds + ctx.m_iTicksAllowed, 16 );

    auto maxShiftedCmds = newCmds - move_msg->m_iNewCmds;
    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    const auto old_new_cmds = move_msg->m_iNewCmds;

    move_msg->m_iNewCmds = std::clamp( move_msg->m_iNewCmds + maxShiftedCmds, 1, 62 );
    move_msg->m_iBackupCmds = 0;


    auto first_tick_base = AdjustTickbase( old_new_cmds, move_msg->m_iNewCmds, maxShiftedCmds );

    const auto nextCmdNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

    static auto oWriteUserCmdDeltaToBuffer = DTR::WriteUserCmdDeltaToBuffer.GetOriginal<decltype( &Hooks::hkWriteUserCmdDeltaToBuffer )>( );
    bool stoplol{ };
    for ( to = nextCmdNumber - old_new_cmds + 1; to <= nextCmdNumber; ++to ) {
        if ( !oWriteUserCmdDeltaToBuffer( ecx, edx, slot, buf, from, to, true ) ) {
            stoplol = true;
            break;
        }

        from = to;
    }

    if ( stoplol )
        return true;

   for ( auto i = Interfaces::ClientState->iLastOutgoingCommand + 1; i <= nextCmdNumber; ++i ) {
        auto& local_data = ctx.m_cLocalData.at( i % 150 );

        local_data.m_iShiftAmount = maxShiftedCmds;
        //local_data.m_iAdjustedTickbase = first_tick_base++;
        //local_data.m_bOverrideTickbase = true;
        //local_data.m_bRestoreTickbase = true;
   }

    const auto user_cmd = Interfaces::Input->GetUserCmd( from );
    if ( !user_cmd )
        return false;

    auto from_user_cmd = *user_cmd, toUserCmd = *user_cmd;

    ++toUserCmd.iCommandNumber;

    toUserCmd.iTickCount = INT_MAX;

    while ( maxShiftedCmds ) {
        WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

        from_user_cmd = toUserCmd;

        ++toUserCmd.iCommandNumber;

        /*if ( finalRun ) {
            auto& LocalData = ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 );
            LocalData.m_bOverrideTickbase = true;
            LocalData.m_iAdjustedTickbase = first_tick_base++;
            LocalData.m_iCommandNumber = toUserCmd.iCommandNumber;
        }*/

        --maxShiftedCmds;
    }

    return false;
}