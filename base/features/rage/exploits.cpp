#include "exploits.h"
#include "../../core/hooks.h"

bool CExploits::ShouldRecharge( ) {
    if ( !ctx.m_bExploitsEnabled )
        return false;

    if ( Config::Get<bool>( Vars.MiscFakeDuck ) && Config::Get<keybind_t>( Vars.MiscFakeDuckKey ).enabled )
        return false;

    if ( ( Interfaces::Globals->flCurTime - ctx.m_pLocal->m_flSpawnTime( ) ) < 1.f )
        return false;

    if ( ctx.m_iTicksAllowed >= 14 )
        return false;

    if ( std::abs( Interfaces::Globals->flRealTime - ctx.m_iLastStopTime ) < 0.5f )
        return false;

    if ( Features::Ragebot.m_bShouldStop )
        return false;

    if ( m_iShiftAmount )
        return false;

    const auto extraTicks{ **( int** )Offsets::Sigs.numticks - **( int** )Offsets::Sigs.host_currentframetick };
    if ( ( 14 - ctx.m_iTicksAllowed ) + extraTicks + Interfaces::ClientState->nChokedCommands >= 16 ) {
        ctx.m_bSendPacket = true;
        return false;
    }

    Features::Exploits.m_iRechargeCmd = Interfaces::ClientState->iLastOutgoingCommand;

    ++ctx.m_iTicksAllowed;

    return true;
}

int CExploits::AdjustTickbase( const int totalNewCmds ) {
    int ret{ };
    const auto extraTicks{ **( int** )Offsets::Sigs.numticks - **( int** )Offsets::Sigs.host_currentframetick };
    const auto tickCount{ Interfaces::ClientState->iServerTick + 2 + TIME_TO_TICKS( ctx.m_flRealOutLatency ) + extraTicks };

    const auto nCorrectionTicks{ ctx.CalcCorrectionTicks( ) };
    if ( nCorrectionTicks != -1 ) {
        const auto& prevLocalData = ctx.m_cLocalData.at( Interfaces::ClientState->iLastOutgoingCommand % 150 );
        if ( prevLocalData.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( ) ) {
            ret = prevLocalData.m_iTickbase + 1;
            if ( prevLocalData.m_bOverrideTickbase )
                ret = prevLocalData.m_iAdjustedTickbase + 1;

            const auto nIdealFinalTick{ tickCount + nCorrectionTicks };

            const auto too_fast_limit{ nIdealFinalTick + nCorrectionTicks };
            const auto too_slow_limit{ nIdealFinalTick - nCorrectionTicks };

            const auto nEstimatedFinalTick{ ret + totalNewCmds };

            if ( nEstimatedFinalTick > too_fast_limit
                || nEstimatedFinalTick < too_slow_limit )
                return nIdealFinalTick - totalNewCmds;
        }
    }
    else
        return tickCount - totalNewCmds;

    const auto& localData{ ctx.m_cLocalData.at( ( Interfaces::ClientState->iLastOutgoingCommand ) % 150 ) };

    if ( localData.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( ) ) {
        ret = localData.m_iTickbase + 1;
        if ( localData.m_bOverrideTickbase )
            ret = localData.m_iAdjustedTickbase + 1;
    }
    else
        ret = tickCount - totalNewCmds;

    return ret;
}

void WriteUserCmd( void* buf, CUserCmd* incmd, CUserCmd* outcmd ) {
    using WriteUsercmd_t = void( __fastcall* )( void*, CUserCmd*, CUserCmd* );
    static WriteUsercmd_t WriteUsercmdF = reinterpret_cast< WriteUsercmd_t >( Offsets::Sigs.WriteUsercmd );

    __asm
    {
        mov     ecx, buf
        mov     edx, incmd
        push    outcmd
        call    WriteUsercmdF
        add     esp, 4
    }
}

void CExploits::Shift( bf_write* buf, MoveMsg_t* moveMsg ) {
    if ( m_bRealCmds && Features::Misc.AutoPeeking && ctx.m_bSafeFromDefensive && ctx.m_bInPeek && Config::Get<bool>( Vars.ExploitsDoubletapExtended ) && Config::Get<bool>( Vars.ExploitsDoubletapDefensive ) ) {
        ctx.m_iLastStopTime = Interfaces::Globals->flRealTime;
        return;
    }

    const auto newCmds{ std::min( moveMsg->m_iNewCmds + m_iShiftAmount, 16 ) };

    auto maxShiftedCmds{ newCmds - moveMsg->m_iNewCmds };

    if ( m_bRealCmds )
        ctx.m_iTicksAllowed -= std::max( maxShiftedCmds, ctx.m_iTicksAllowed );
    else
        ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    moveMsg->m_iNewCmds = std::clamp( moveMsg->m_iNewCmds + maxShiftedCmds, 1, 62 );

    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    auto firstTickBase{ AdjustTickbase( newCmds ) };

    for ( auto i{ Interfaces::ClientState->iLastOutgoingCommand + 1 };
        i <= Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1; ++i ) {
        ctx.m_cLocalData.at( nextCmdNumber % 150 ).m_bOverrideTickbase = true;
        ctx.m_cLocalData.at( nextCmdNumber % 150 ).m_iAdjustedTickbase = firstTickBase++;
    }

    const auto userCmd = Interfaces::Input->GetUserCmd( nextCmdNumber );
    if ( !userCmd )
        return;

    //userCmd->iCommandNumber = nextCmdNumber;

    auto from_user_cmd = *userCmd, toUserCmd = *userCmd;
    if ( m_bRealCmds ) {
        ctx.m_bCanShoot = ctx.m_pLocal->CanShoot( );
        Features::Ragebot.Main( *userCmd, false );
        auto shouldStop{ Features::Ragebot.m_bShouldStop };

        toUserCmd.viewAngles = ctx.m_angOriginalViewangles;

        while ( maxShiftedCmds > 0 ) {
            // pre one is compensated for and last isn't so this is perfect
            ++Interfaces::ClientState->nChokedCommands;
            ++Interfaces::ClientState->pNetChannel->iChokedPackets;
            ++Interfaces::ClientState->pNetChannel->iOutSequenceNr;
            ++toUserCmd.iCommandNumber;

            auto& localData{ ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 ) };
            localData.Save( ctx.m_pLocal, toUserCmd, ctx.m_pWeapon );
            localData.m_bOverrideTickbase = true;
            localData.m_iAdjustedTickbase = firstTickBase++;
            localData.m_iCommandNumber = toUserCmd.iCommandNumber;
            ctx.m_pLocal->m_nTickBase( ) = localData.m_iAdjustedTickbase;

            ctx.m_flFixedCurtime = TICKS_TO_TIME( ctx.m_pLocal->m_nTickBase( ) );

            --maxShiftedCmds;

            Interfaces::Globals->flCurTime = ctx.m_flFixedCurtime;

            //Interfaces::Prediction->iPreviousStartFrame = 0xFADED;
            //Interfaces::Prediction->Split->nCommandsPredicted = 0;
            //Interfaces::Prediction->Split->nServerCommandsAcknowledged = 0xFADED;

            Interfaces::Prediction->Update( Interfaces::ClientState->iDeltaTick,
                true,
                Interfaces::ClientState->iLastCommandAck,
                Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands );

            ctx.m_bCanShoot = ctx.m_pLocal->CanShoot( );

            if ( maxShiftedCmds == 4 ) {
                Features::Ragebot.Main( *userCmd, false );
                shouldStop = Features::Ragebot.m_bShouldStop;
            }

            localData.SavePredVars( ctx.m_pLocal, toUserCmd );


            toUserCmd.iButtons &= ~( IN_ATTACK | IN_ATTACK2 | IN_BULLRUSH | IN_SPEED | IN_WALK | IN_ZOOM | IN_JUMP );
            //toUserCmd.iButtons &= ~( 0x801u );
            toUserCmd.flForwardMove = Features::Misc.m_ve2OldMovement.x;
            toUserCmd.flSideMove = Features::Misc.m_ve2OldMovement.y;

            if ( ctx.m_pLocal->m_MoveType( ) == MOVETYPE_WALK ) {
                if ( Config::Get<bool>( Vars.MiscBunnyhop ) && Features::Misc.m_bWasJumping ) {
                    if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND )
                        toUserCmd.iButtons |= IN_JUMP;
                }

                if ( !Features::Misc.AutoStop( toUserCmd ) )
                    Features::Misc.SlowWalk( toUserCmd );

                if ( shouldStop )
                    Features::Ragebot.m_bShouldStop = shouldStop;
            }

            const auto backupCS{ ctx.m_bCanShoot };
            ctx.m_bCanShoot = false;
            Features::Misc.AutoPeek( toUserCmd );
            ctx.m_bCanShoot = backupCS;

            Features::Misc.MoveMINTFix( toUserCmd, ctx.m_angOriginalViewangles, ctx.m_pLocal->m_fFlags( ), ctx.m_pLocal->m_MoveType( ) );
            Features::Misc.NormalizeMovement( toUserCmd );

            Features::AnimSys.UpdateLocal( toUserCmd.viewAngles, true, toUserCmd );

            Interfaces::Input->pCommands[ toUserCmd.iCommandNumber % 150 ] = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );

            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );
            from_user_cmd = toUserCmd;
        }

        Interfaces::Prediction->iPreviousStartFrame = -1;
        Interfaces::Prediction->Split->nCommandsPredicted = 0;
        //Interfaces::Prediction->Split->nServerCommandsAcknowledged = 0xFADED;

        ctx.m_cFakeData.m_sState = *ctx.m_pLocal->m_pAnimState( );
        std::memcpy( ctx.m_pAnimationLayers, ctx.m_pLocal->m_AnimationLayers( ), 13 * sizeof CAnimationLayer );
    }
    else {
        Features::Exploits.m_bResetNextTick = true;

        toUserCmd.iTickCount = INT_MAX;
        toUserCmd.iCommandNumber = 0;

        while ( maxShiftedCmds ) {

            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );
            from_user_cmd = toUserCmd;

            --maxShiftedCmds;
        }
    }

    m_iShiftAmount = 0;
}

void CExploits::BreakLC( bf_write* buf, int shift, MoveMsg_t* moveMsg ) {
    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    const auto newCmds{ std::min( moveMsg->m_iNewCmds + shift, 16 ) };

    auto maxShiftedCmds{ newCmds - moveMsg->m_iNewCmds };
    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    moveMsg->m_iNewCmds = std::clamp( moveMsg->m_iNewCmds + maxShiftedCmds, 1, 62 );

    auto firstTickBase{ AdjustTickbase( moveMsg->m_iNewCmds ) };

    for ( auto i{ Interfaces::ClientState->iLastOutgoingCommand + 1 };
        i <= Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1; ++i ) {
        ctx.m_cLocalData.at( nextCmdNumber % 150 ).m_iAdjustedTickbase = firstTickBase++;
    }
    const auto user_cmd = Interfaces::Input->GetUserCmd( nextCmdNumber );
    if ( !user_cmd )
        return;

    auto from_user_cmd = *user_cmd, toUserCmd = *user_cmd;

    toUserCmd.iTickCount = INT_MAX;
    toUserCmd.iCommandNumber = 0;

    while ( maxShiftedCmds ) {

        WriteUserCmd( buf, &toUserCmd, &from_user_cmd );
        from_user_cmd = toUserCmd;

        --maxShiftedCmds;
    }
}