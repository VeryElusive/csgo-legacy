#include "exploits.h"
#include "../../core/hooks.h"

bool CExploits::ShouldRecharge( ) {
    if ( !ctx.m_bExploitsEnabled )
        return false;

    if ( Config::Get<bool>( Vars.MiscFakeDuck ) && Config::Get<keybind_t>( Vars.MiscFakeDuckKey ).enabled )
        return false;

    if ( ( Interfaces::Globals->flCurTime - ctx.m_pLocal->m_flSpawnTime( ) ) < 1.f )
        return false;

    if ( ctx.m_iTicksAllowed >= 14 )
        return false;

    const auto extraTicks{ **( int** )Offsets::Sigs.numticks - **( int** )Offsets::Sigs.host_currentframetick - 1 };

    if ( extraTicks + ctx.m_iTicksAllowed + 1 >= 16 )
        return false;

    if ( std::abs( Interfaces::Globals->flRealTime - ctx.m_iLastShotTime ) < 0.5f )
        return false;

    if ( Features::Ragebot.m_bShouldStop )
        return false;

    if ( Features::Exploits.m_iRechargeCmd != Interfaces::ClientState->iLastOutgoingCommand
        && Interfaces::ClientState->nChokedCommands > 1 ) {
        ctx.m_bSendPacket = true;
        return false;
    }

    Features::Exploits.m_iRechargeCmd = Interfaces::ClientState->iLastOutgoingCommand;

    ++ctx.m_iTicksAllowed;

    return true;
}

int CExploits::AdjustTickbase( const int oldNewCmds, const int totalNewCmds, const int delta ) {
    auto ret{ -1 };

    const auto nCorrectionTicks{ ctx.CalcCorrectionTicks( ) };
    if ( nCorrectionTicks != -1 ) {
        const auto& prevLocalData = ctx.m_cLocalData.at( Interfaces::ClientState->iLastOutgoingCommand % 150 );
        if ( prevLocalData.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( ) ) {
            const auto tickCount{ Interfaces::ClientState->iServerTick + TIME_TO_TICKS( ctx.m_flRealOutLatency ) + m_iCorrectionAmount };// will round up, which is what we want generally

            const auto nIdealFinalTick{ tickCount + nCorrectionTicks };

            const auto too_fast_limit{ nIdealFinalTick + nCorrectionTicks };
            const auto too_slow_limit{ nIdealFinalTick - nCorrectionTicks };

            const auto nEstimatedFinalTick{ ret + totalNewCmds };

            if ( nEstimatedFinalTick > too_fast_limit
                || nEstimatedFinalTick < too_slow_limit )
                ret = nIdealFinalTick - totalNewCmds;
        }
    }

    if ( ret != -1 )
        return ret;

    const auto& localData{ ctx.m_cLocalData.at( ( Interfaces::ClientState->iLastOutgoingCommand + 1 ) % 150 ) };

    return ( localData.m_flSpawnTime == ctx.m_pLocal->m_flSpawnTime( )
        ? localData.PredictedNetvars.m_nTickBase : ctx.m_pLocal->m_nTickBase( ) ) - delta;
}

void WriteUserCmd( void* buf, CUserCmd* incmd, CUserCmd* outcmd ) {
    using WriteUsercmd_t = void( __fastcall* )( void*, CUserCmd*, CUserCmd* );
    static WriteUsercmd_t WriteUsercmdF = reinterpret_cast< WriteUsercmd_t >( Offsets::Sigs.WriteUsercmd );

    __asm
    {
        mov     ecx, buf
        mov     edx, incmd
        push    outcmd
        call    WriteUsercmdF
        add     esp, 4
    }
}


bool CExploits::Shift( void* ecx, void* edx, int slot, bf_write* buf, int from, int to, MoveMsg_t* moveMsg ) {
    //const auto extraTicks{ **( int** )Offsets::Sigs.numticks - 1 };//host_currentframetick not needed

    const auto newCmds{ std::min( moveMsg->m_iNewCmds + ctx.m_iTicksAllowed, 16 ) };

    auto maxShiftedCmds{ newCmds - moveMsg->m_iNewCmds };
    auto shiftAmount{ maxShiftedCmds };

    if ( m_bRealCmds )
        maxShiftedCmds -= m_iShiftAmount;

    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    const auto oldNewCmds{ moveMsg->m_iNewCmds };

    moveMsg->m_iNewCmds = std::clamp( moveMsg->m_iNewCmds + shiftAmount, 1, 62 );
    moveMsg->m_iBackupCmds = 0;

    auto firstTickBase{ AdjustTickbase( oldNewCmds, moveMsg->m_iNewCmds, shiftAmount ) };

    const auto nextCmdNumber{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    static auto oWriteUserCmdDeltaToBuffer = DTR::WriteUserCmdDeltaToBuffer.GetOriginal<decltype( &Hooks::hkWriteUserCmdDeltaToBuffer )>( );
    bool stoplol{ };
    for ( to = nextCmdNumber - oldNewCmds + 1; to <= nextCmdNumber; ++to ) {
        if ( !oWriteUserCmdDeltaToBuffer( ecx, edx, slot, buf, from, to, true ) ) {
            stoplol = true;
            break;
        }

        from = to;
    }

    if ( stoplol )
        return true;

    for ( auto i = Interfaces::ClientState->iLastOutgoingCommand + 1; i <= nextCmdNumber; ++i ) {
        auto& local_data = ctx.m_cLocalData.at( i % 150 );

        local_data.m_iShiftAmount = m_bRealCmds ? 0 : shiftAmount;
        local_data.m_iAdjustedTickbase = firstTickBase++;
        local_data.m_bOverrideTickbase = true;
        local_data.m_bRestoreTickbase = !m_bRealCmds;
    }

    const auto userCmd = Interfaces::Input->GetUserCmd( from );
    if ( !userCmd )
        return false;

    auto from_user_cmd = *userCmd, toUserCmd = *userCmd;

    if ( m_bRealCmds ) {
        while ( shiftAmount > 0 ) {
            ++Interfaces::ClientState->nChokedCommands;
            ++Interfaces::ClientState->pNetChannel->iChokedPackets;
            ++Interfaces::ClientState->pNetChannel->iOutSequenceNr;

            ++toUserCmd.iCommandNumber;

            --shiftAmount;

            toUserCmd.iButtons &= ~( IN_ATTACK | IN_ATTACK2 | IN_USE | IN_BULLRUSH | IN_SPEED | IN_WALK | IN_ZOOM | IN_JUMP );
            toUserCmd.flForwardMove = Features::Misc.m_ve2OldMovement.x;
            toUserCmd.flSideMove = Features::Misc.m_ve2OldMovement.y;

            Interfaces::Prediction->Update( Interfaces::ClientState->iDeltaTick,
                Interfaces::ClientState->iDeltaTick > 0,
                Interfaces::ClientState->iLastCommandAck,
                Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands );

            Interfaces::Prediction->iPreviousStartFrame = -1;
            Interfaces::Prediction->Split->nCommandsPredicted = 0;

            if ( Config::Get<bool>( Vars.MiscBunnyhop ) && Features::Misc.m_bWasJumping ) {
                if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND )
                    toUserCmd.iButtons |= IN_JUMP;
            }

            if ( ctx.m_pLocal->m_fFlags( ) & FL_ONGROUND
                && ( toUserCmd.flForwardMove || toUserCmd.flSideMove ) 
                && shiftAmount <= 1
                && Config::Get<bool>( Vars.ExploitsDoubletap ) && Config::Get<keybind_t>( Vars.ExploitsDoubletapKey ).enabled ) {
                toUserCmd.flForwardMove = 0;
                toUserCmd.flSideMove = 0;

                Features::Ragebot.m_bShouldStop = true;
                Features::Misc.AutoStop( toUserCmd );
                Features::Ragebot.m_bShouldStop = false;
            }

            Features::Misc.AutoPeek( toUserCmd );
            Features::Misc.MoveMINTFix( toUserCmd, ctx.m_angOriginalViewangles, ctx.m_pLocal->m_fFlags( ), ctx.m_pLocal->m_MoveType( ) );
            Features::Misc.NormalizeMovement( toUserCmd );

            Features::AnimSys.UpdateLocal( toUserCmd.viewAngles, shiftAmount );

            auto& LocalData = ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 );
            LocalData.m_bOverrideTickbase = true;
            LocalData.m_iAdjustedTickbase = firstTickBase++;
            LocalData.m_iCommandNumber = toUserCmd.iCommandNumber;

            Interfaces::Input->pCommands[ toUserCmd.iCommandNumber % 150 ] = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].userCmd = toUserCmd;
            Interfaces::Input->pVerifiedCommands[ toUserCmd.iCommandNumber % 150 ].uHashCRC = toUserCmd.GetChecksum( );

            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

            from_user_cmd = toUserCmd;
        }

        ctx.m_iSentCmds.push_back( Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 );
    }
    else {
        toUserCmd.iTickCount = 0xFADED;

        while ( shiftAmount ) {
            ++toUserCmd.iCommandNumber;

            WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

            from_user_cmd = toUserCmd;

            auto& LocalData = ctx.m_cLocalData.at( toUserCmd.iCommandNumber % 150 );
            LocalData.m_bOverrideTickbase = true;
            LocalData.m_iAdjustedTickbase = firstTickBase++;
            LocalData.m_iCommandNumber = toUserCmd.iCommandNumber;

            --shiftAmount;
        }
    }

    return false;
}

bool CExploits::BreakLC( void* ecx, void* edx, int slot, bf_write* buf, int from, int to, MoveMsg_t* move_msg ) {
    const auto extraTicks{ **( int** )Offsets::Sigs.numticks - 1 };

    const auto newCmds = std::min( move_msg->m_iNewCmds + extraTicks + ctx.m_iTicksAllowed, 16 );
    auto maxShiftedCmds = newCmds - move_msg->m_iNewCmds - extraTicks;

    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    const auto old_new_cmds = move_msg->m_iNewCmds;

    move_msg->m_iNewCmds = std::clamp( move_msg->m_iNewCmds + maxShiftedCmds, 1, 62 );
    move_msg->m_iBackupCmds = 0;


    auto first_tick_base = AdjustTickbase( old_new_cmds, move_msg->m_iNewCmds, maxShiftedCmds );

    const auto nextCmdNumber = Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1;

    static auto oWriteUserCmdDeltaToBuffer = DTR::WriteUserCmdDeltaToBuffer.GetOriginal<decltype( &Hooks::hkWriteUserCmdDeltaToBuffer )>( );
    bool stoplol{ };
    for ( to = nextCmdNumber - old_new_cmds + 1; to <= nextCmdNumber; ++to ) {
        if ( !oWriteUserCmdDeltaToBuffer( ecx, edx, slot, buf, from, to, true ) ) {
            stoplol = true;
            break;
        }
    }

    if ( stoplol )
        return true;

  // for ( auto i = Interfaces::ClientState->iLastOutgoingCommand + 1; i <= nextCmdNumber; ++i ) 
  //     ctx.m_cLocalData.at( i % 150 ).m_iShiftAmount = maxShiftedCmds;

    const auto user_cmd = Interfaces::Input->GetUserCmd( from );
    if ( !user_cmd )
        return false;

    auto from_user_cmd = *user_cmd, toUserCmd = *user_cmd;

    toUserCmd.iTickCount = 0xFADED;

    while ( maxShiftedCmds ) {
        ++toUserCmd.iCommandNumber;

        WriteUserCmd( buf, &toUserCmd, &from_user_cmd );

        from_user_cmd = toUserCmd;

        --maxShiftedCmds;
    }

    return false;
}

/*void CExploits::Shift( ) {
    static auto oCL_Move{ DTR::CL_Move.GetOriginal<decltype( &Hooks::hkCL_Move )>( ) };

    const auto extraTicks{ **( int** )Offsets::Sigs.numticks - 1 };

    const auto newCmds{ std::min( Interfaces::ClientState->nChokedCommands + extraTicks + ctx.m_iTicksAllowed, 16 ) };
    auto maxShiftedCmds{ newCmds - Interfaces::ClientState->nChokedCommands - extraTicks };

    ctx.m_iTicksAllowed = std::max( maxShiftedCmds, 0 );

    auto firstTickBase{ AdjustTickbase( Interfaces::ClientState->nChokedCommands + extraTicks, ctx.m_iTicksAllowed, ctx.m_iTicksAllowed ) };
    const auto nextCmdNum{ Interfaces::ClientState->iLastOutgoingCommand + Interfaces::ClientState->nChokedCommands + 1 };

    for ( auto i = Interfaces::ClientState->iLastOutgoingCommand + 1; i <= nextCmdNum; ++i ) {
        auto& localData{ ctx.m_cLocalData.at( i % 150 ) };

        localData.m_iAdjustedTickbase = firstTickBase++;
        localData.m_bOverrideTickbase = true;
    }

    const auto shiftAmt{ ctx.m_iTicksAllowed };

    while ( ctx.m_iTicksAllowed ) {
        --ctx.m_iTicksAllowed;

        auto& localData = ctx.m_cLocalData.at( ( nextCmdNum + shiftAmt - ctx.m_iTicksAllowed ) % 150 );

        localData.m_iAdjustedTickbase = firstTickBase++;
        localData.m_bOverrideTickbase = true;

        oCL_Move( 0.f, !ctx.m_iTicksAllowed );
    }

    Features::Exploits.m_iShiftAmount = 0;
}
*/